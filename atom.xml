<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Woody Tells</title>
  
  <subtitle>Never Settle</subtitle>
  <link href="http://woody5962.github.io/atom.xml" rel="self"/>
  
  <link href="http://woody5962.github.io/"/>
  <updated>2021-07-01T12:41:18.121Z</updated>
  <id>http://woody5962.github.io/</id>
  
  <author>
    <name>Woody</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集束搜索</title>
    <link href="http://woody5962.github.io/%E9%9B%86%E6%9D%9F%E6%90%9C%E7%B4%A2/"/>
    <id>http://woody5962.github.io/%E9%9B%86%E6%9D%9F%E6%90%9C%E7%B4%A2/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2021-07-01T12:41:18.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>举例说明，在NLP领域中，经常会涉及机器翻译结果的搜索，比如在decoder中，我们可以使用贪心策略每次选择softmax值最高的，但是由于贪心解往往达不到最优，所以我们放松贪心约束，每次选择最优的k个，k便是集束宽度，这样对解的搜索叫做集束搜索。</p><h2 id="过程示例"><a href="#过程示例" class="headerlink" title="过程示例"></a>过程示例</h2><p>假设字典为[a,b,c]，beam size选择2，则如下图有：</p><p><img src="../images/jishu1.png" alt="jishu"></p><ol><li><p>在生成第1个词的时候，选择概率最大的2个词，那么当前序列就是a或b</p></li><li><p>生成第2个词的时候，我们将当前序列a或b，分别与字典中的所有词进行组合，得到新的6个序列aa ab ac ba bb bc,然后从其中选择2个概率最高的，作为当前序列，即ab或bb</p></li></ol><p>不断重复这个过程，直到遇到结束符为止。最终输出2个概率最高的序列。</p><p>显然集束搜索属于贪心算法，不能保证一定能够找到全局最优解，因为考虑到搜索空间太大，而采用一个相对的较优解。</p><p>而贪心搜索由于每次考虑当下词的概率，而通常英文中有些常用结构，比如吴恩达网课中的例子：“is going”，出现概率较大，会导致模型最终生成的句子过于冗余，如“is visiting”和“is going to be visiting”。</p><p>贪心搜索可以认为beam size为1时的集束搜索特例。</p>]]></content>
    
    
    <summary type="html">集束搜索的思想和算法步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>爬山法</title>
    <link href="http://woody5962.github.io/%E7%88%AC%E5%B1%B1%E6%B3%95/"/>
    <id>http://woody5962.github.io/%E7%88%AC%E5%B1%B1%E6%B3%95/</id>
    <published>2019-09-21T16:00:00.000Z</published>
    <updated>2021-07-01T11:02:31.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>爬山法假设当前解和周围的解是有变化规律的，如，当前解得下方有一个代价较小的解，则我们就认为，沿着这个方向走，解会越来越小。</p><p>该算法将搜索过程比作爬山过程，在没有任何有关山顶的其他信息的情况下，沿着高度增加的方向爬。如果相邻状态没有比当前值更高，则算法停止，认为当前值即为顶峰。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>设置初始状态n=s0为当前状态;</li><li>如果当前状态已达标，算法结束，搜索成功;</li><li>获取当前状态n的若干个临近状态m,计算这些h(m), nextn=min{h(m)}；</li><li>IF h(n) &gt; h(nextn)<br> THEN  n:=nextn;<br> ELSE 取当前状态为最佳状态并退出;</li><li>GOTO 2步;</li></ol><p>实际操作中：</p><ul><li><p>循环改变解的每一个值产生一个临近解的列表</p></li><li><p>对所有的临近解计算代价并排序，选择代价符合要求的的解</p></li></ul><p>对于单峰来说，必定能找到最优点。</p>]]></content>
    
    
    <summary type="html">爬山法的思想和算法步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="爬山法" scheme="http://woody5962.github.io/tags/%E7%88%AC%E5%B1%B1%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="http://woody5962.github.io/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <id>http://woody5962.github.io/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</id>
    <published>2019-09-21T16:00:00.000Z</published>
    <updated>2021-07-01T10:56:58.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这个方法来自金属热加工过程的启发。在金属热加工过程中，当金属的温度超过它的熔点（Melting Point）时，原子就会激烈地随机运动。与所有的其它的物理系统相类似，原子的这种运动趋向于寻找其能量的极小状态。在这个能量的变迁过程中，开始时，温度非常高， 使得原子具有很高的能量。随着温度不断降低，金属逐渐冷却，金属中的原子的能量就越来越小，最后达到所有可能的最低点。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>利用模拟退火的时候，让算法从较大的跳跃开始，使到它有足够的“能量”逃离可能“路过”的局部最优解而不至于限制在其中，当它停在全局最优解附近的时候，逐渐的减小跳跃量，以便使其“落脚 ”到全局最优解上。</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>从一个问题的原始解开始，用一个变量代表温度，这一温度开始时非常高，而后逐步减低。在每一次迭代期间，算法会随机选中题解中的某个数字，使其发生细微变化，而后计算该解的代价。关键的地方在于计算出该解的代价后，如何决定是否接受该解。<br>如果新的成本更低，则新的题解就会变成当前题解，这与爬山法类似；如果新的成本更高，则新的题解与概率 P 被接受（一开始的时候，T很高，导致P很大，于是就有了足够的能量逃离局部最优）。这一概率会随着温度T的降低而降低。即算法开始时，可以接受表现较差的解，随着退火过程中温度的不断下降，算法越来越不可以接受较差的解，知道最后，它只会接受更优的解。<br>其中P = exp[-（newcost - oldcost）/ T ]<br>其中newcost是新解的成本，oldcost是当前成本，T为当前温度。算法以概率P接受新的解。可见，当温度很高或者新旧解差别很大时，概率P都会很大。</p>]]></content>
    
    
    <summary type="html">模拟退火算法的思想和算法步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="模拟退火算法" scheme="http://woody5962.github.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>蚁群算法</title>
    <link href="http://woody5962.github.io/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <id>http://woody5962.github.io/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2021-06-30T16:57:18.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>将蚁群算法应用于解决优化问题的基本思路为：用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上累积的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</p><h2 id="算法流程（蚁群解决TSP）"><a href="#算法流程（蚁群解决TSP）" class="headerlink" title="算法流程（蚁群解决TSP）"></a>算法流程（蚁群解决TSP）</h2><p><img src="../images/yiqun1.jpg" alt="yiqun"></p><h3 id="选择下一座城市的规则"><a href="#选择下一座城市的规则" class="headerlink" title="选择下一座城市的规则"></a>选择下一座城市的规则</h3><p><img src="../images/yiqun2.png" alt="yiqun"></p><ul><li><p>由选择公式可见，分母是所有可选路径的信息素的和，而某路径信息素越浓，选中它的概率越大。</p></li><li><p>同时，给出了beta参数作为启发信息的权重，在这里，启发信息正如其名，是一种启发，根据其初值可知，哪条路径最短，其被选中的概率就越高。在早期，就是这样的启发信息来促使算法少走弯路。</p></li></ul><h3 id="信息素更新规则"><a href="#信息素更新规则" class="headerlink" title="信息素更新规则"></a>信息素更新规则</h3><p><img src="../images/yiqun3.png" alt="yiqun"></p><p><img src="../images/yiqun4.png" alt="yiqun"></p><ul><li><p>当Lk 计算完毕之后，得到目前最优解，根据最优解的路径更新信息素。</p></li><li><p>可见，信息素在更新之前，先削弱了旧信息素的影响，然后将最优路径的信息素添加进去，由于最优，所以L小，信息素大。</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>实际实验中发现，当蚂蚁在一条路径上觅食很久时，放置一个近的食物基本没有效果，这可以理解为当一只蚂蚁找到一条路径时，在经过很长时间后大多数蚂蚁都选择了这条路径，这时，突然有一只蚂蚁找到了较近的食物，但因为时间过得太久，两条路径上浓度相差太大（浓度越大，被选择的概率就越大），整个系统基本已经停滞了，陷入了局部最优。</p>]]></content>
    
    
    <summary type="html">蚁群算法思想和步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="蚁群算法" scheme="http://woody5962.github.io/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>局部搜索算法</title>
    <link href="http://woody5962.github.io/%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2/"/>
    <id>http://woody5962.github.io/%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2021-07-01T10:50:40.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>总是去找可能含有较优点的子集，最终找到的不一定是最优的点，但是具有较强的局部搜索能力。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>随机选择一个初始的可能解x0 ∈D，xb=x0,P=N(xb)。<br>D是问题的定义域， xb用于记录到目标位置的最优解，P为xb的邻域。</li><li>如果不满足结束条件，则：</li></ol><p>Begin；</p><ul><li>选择P的一个子集P’，xn为P’的最优解。P’可根据问题特点，选择适当大小的子集。可按概率选择；</li><li>如果f(xn)&lt;f(xb)，则xb=xn，P=N(xb)，转2；</li><li>否则P=P-P’，转2；</li></ul><p>End（结束条件为循环次数或P为空等）；</p><ol start="3"><li>输出计算结果；</li><li>结束</li></ol>]]></content>
    
    
    <summary type="html">局部搜索的算法思想和步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机搜索算法</title>
    <link href="http://woody5962.github.io/%E9%9A%8F%E6%9C%BA%E6%90%9C%E7%B4%A2/"/>
    <id>http://woody5962.github.io/%E9%9A%8F%E6%9C%BA%E6%90%9C%E7%B4%A2/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2021-07-01T10:55:06.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于该算法"><a href="#关于该算法" class="headerlink" title="关于该算法"></a>关于该算法</h2><p>随机搜索算法时最简单的优化搜索算法。</p><p>类似于调参过程中的随机搜索，当不知道代价函数在值域范围内的变化规律时，可以使用随机算法对解进行搜索。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>只适用于代价函数在值域范围内没有任何变化规律的情况，即找不到任何使得代价下降的梯度和极小值点。</p><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>只需要在值域范围内生成足够多的可行解，然后分别计算每个可行解的代价，根据代价选择一个最小的可行解作为随机搜索的最优解即可。</p>]]></content>
    
    
    <summary type="html">随机搜索的简介</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粒子群优化算法</title>
    <link href="http://woody5962.github.io/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <id>http://woody5962.github.io/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</id>
    <published>2019-09-18T16:00:00.000Z</published>
    <updated>2021-06-30T16:57:34.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>假设有一群鸟，在随机搜索食物，在搜索区域内只有一块儿食物，一开始时所有的鸟儿都不知道食物所在的方位，但它们能够知道自己离食物有多远，以及它们能够记住在自己飞过的路程当中距离食物最近的位置，同时它们也能够知道鸟群中所有鸟儿经过的路程当中，离食物最近的位置。那每一只鸟儿将如何去寻找食物呢？简单来说，每一只鸟儿在当前位置的基础上，如何做出决策，下一步向哪里飞呢？实际，每只鸟儿将综合自身的经验，以及群体的经验来在做出下一步飞向哪里的决策，即每只鸟儿将根据自己所经过的路程中离食物最近的位置以及鸟群中所有鸟儿经过的路程当中离食物最近的位置来做出决策，决定下一步自己向哪里飞。</p><p>在粒子群算法中，粒子的位置对应于原问题的解。粒子的适应值就是将粒子的位置（对应于原问题的解）带入到目标函数中所得到的目标函数值。粒子的速度决定粒子下一步向哪里飞以及飞多远。</p><h2 id="核心公式"><a href="#核心公式" class="headerlink" title="核心公式"></a>核心公式</h2><p><img src="../images/pso1.png" alt="gs"></p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><p><img src="../images/pso2.png" alt="gs"></p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>粒子群算法整合了个体与整体的智慧，在“信息素”更新的时候，综合考虑了个体和整体在过去的发现。调整参数可以避免陷入局部最优，同时也可以决定对个体或者整体的依赖程度。个人认为，整体越大，对整体的依赖程度就要越大，这个依赖程度应该和粒子数量成正相关关系。</p>]]></content>
    
    
    <summary type="html">粒子群优化算法的背景、原理以及一些个人理解</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="粒子群算法" scheme="http://woody5962.github.io/tags/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>禁忌搜索算法</title>
    <link href="http://woody5962.github.io/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2/"/>
    <id>http://woody5962.github.io/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2/</id>
    <published>2019-09-18T16:00:00.000Z</published>
    <updated>2021-07-01T10:50:18.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><img src="../images/jinji1.png" alt="jinji"><br>通过保持一个禁忌表，以禁忌长度进行禁忌，遵守禁忌准则和藐视准则进行全局搜索。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先，我们对置换问题定义一种邻域搜索结构，如互换操作（SWAP），即随机交换两个点的位置，则每个状态的邻域解有Cn2=n（n一1）/2个。称从一个状态转移到其邻域中的另一个状态为一次移动（move），显然每次移动将导致适配值（反比于目标函数值）的变化。其次，我们采用一个存储结构来区分移动的属性，即是否为禁忌“对象”在以下示例中：考虑7元素的置换问题，并用每一状态的相应21个邻域解中最优的5次移动（对应最佳的5个适配值）作为候选解；为一定程度上防止迂回搜索，每个被采纳的移动在禁忌表中将滞留3步（即禁忌长度），即将移动在以下连续3步搜索中将被视为禁忌对象；需要指出的是，由于当前的禁忌对象对应状态的适配值可能很好，因此在算法中设置判断，若禁忌对象对应的适配值优于“ best so far”状态，则无视其禁忌属性而仍采纳其为当前选择，也就是通常所说的藐视准则（或称特赦准则）。<br>注意，出于改善算法的优化时间性能的考虑，若领域结构决定了大量的领域解（尤其对大规模问题，如TSP的SWAP操作将产生Cn2个领域解），则可以仅尝试部分互换的结果，而候选解也仅取其中的少量最佳状态。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>简单TS算法的基本思想是：给定一个当前解（初始解）和一种邻域，然后在当前解的邻域中确定若干候选解；若最佳候选解对应的目标值优于“best so far”状态，则忽视其禁忌特性，用其替代当前解和“best so far”状态，并将相应的对象加入禁忌表，同时修改禁忌表中各对象的任期；若不存在上述候选解，则选择在候选解中选择非禁忌的最佳状态为新的当前解，而无视它与当前解的优劣，同时将相应的对象加入禁忌表，并修改禁忌表中各对象的任期；如此重复上述迭代搜索过程，直至满足停止准则。</p><p>　　条理化些，则简单禁忌搜索的算法步骤可描述如下：</p><p>　　（1）给定算法参数，随机产生初始解x，置禁忌表为空。</p><p>　　（2）判断算法终止条件是否满足？若是，则结束算法并输出优化结果；否则，继续以下步骤。</p><p>　　（3）利用当前解工的邻域函数产生其所有（或若干）邻域解，并从中确定若干候选解。</p><p>　　（4）对候选解判断藐视准则是否满足？若成立，则用满足藐视准则的最佳状态y替代x成为新的当前解，即x=y，并用与y对应的禁忌对象替换最早进入禁忌表的禁忌对象，同时用y替换“best so far”状态，然后转步骤6；否则，继续以下步骤。</p><p>　　（5）判断候选解对应的各对象的禁忌属性，选择候选解集中非禁忌对象对应的最佳状态为新的当前解，同时用与之对应的禁忌对象替换最早进入禁忌表的禁忌对象元素。</p><p>　　（6）转步骤（2）。</p><p>注意，根据（5）可知，最牛逼的解根本就不考虑它是不是在禁忌列表中，如果这些候选解都很弟弟，那就找非禁忌里面最优的了。这样，既可以保证不遗漏全局最优，又有利于跳出局部最优。</p>]]></content>
    
    
    <summary type="html">禁忌搜索的算法思想和步骤</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://woody5962.github.io/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进化算法</title>
    <link href="http://woody5962.github.io/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://woody5962.github.io/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</id>
    <published>2019-09-17T16:00:00.000Z</published>
    <updated>2021-06-30T16:57:38.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>进化算法主要包括：</p><ul><li>遗传算法</li><li>进化程序设计</li><li>进化规划</li><li>进化策略</li></ul><p>之后的文章记录遗传算法、进化规划、进化策略三种算法的理解。</p><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>适者生存，优胜劣汰！</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="概念0：编码与解码"><a href="#概念0：编码与解码" class="headerlink" title="概念0：编码与解码"></a>概念0：编码与解码</h4><p>要将问题进行数学建模，将问题的解利用二进制数字串进行表示。<br>而进行适应度分析时，要将其解码成特征进行评价。</p><h4 id="概念1：基因和染色体"><a href="#概念1：基因和染色体" class="headerlink" title="概念1：基因和染色体"></a>概念1：基因和染色体</h4><p>在遗传算法中，我们首先需要将要解决的问题映射成一个数学问题，也就是所谓的“数学建模”，那么这个问题的一个可行解即被称为一条“染色体”。一个可行解一般由多个元素构成，那么这每一个元素就被称为染色体上的一个“基因”。</p><h4 id="概念2：适应度函数"><a href="#概念2：适应度函数" class="headerlink" title="概念2：适应度函数"></a>概念2：适应度函数</h4><p>给染色体打分（评价解的优良程度）</p><h4 id="概念3：交叉"><a href="#概念3：交叉" class="headerlink" title="概念3：交叉"></a>概念3：交叉</h4><p>遗传算法每一次迭代都会生成N条染色体，在遗传算法中，这每一次迭代就被称为一次“进化”。交叉算子种类很多，具体使用时找收藏夹，要注意有的交叉算子处理之后要进行冲突检查。</p><h4 id="概念4：变异"><a href="#概念4：变异" class="headerlink" title="概念4：变异"></a>概念4：变异</h4><p>当我们通过交叉生成了一条新的染色体后，需要在新染色体上随机选择若干个基因，然后随机修改基因的值，从而给现有的染色体引入了新的基因，突破了当前搜索的限制，更有利于算法寻找到全局最优解。交叉只能找到局部最优解，永远没有办法达到全局最优解。</p><h4 id="概念5：复制"><a href="#概念5：复制" class="headerlink" title="概念5：复制"></a>概念5：复制</h4><p>每次进化中，为了保留上一代优良的染色体，需要将上一代中适应度最高的几条染色体直接原封不动地复制给下一代。假设每次进化都需生成N条染色体，那么每次进化中，通过交叉方式需要生成N-M条染色体，剩余的M条染色体通过复制上一代适应度最高的M条染色体而来。</p><h4 id="概念6：选择"><a href="#概念6：选择" class="headerlink" title="概念6：选择"></a>概念6：选择</h4><p>如何从群体中找到染色体进行交叉，这涉及到一定的选择策略，常用的有轮盘赌选择策略、锦标赛选择策略、线性排序选择（Linear Ranking Selection）和指数排序选择（Exponential Ranking Selection）。后面两种选择策略避免了轮盘赌的一个缺点，那就是可以让适应度为0的个体也有机会产生后代（会确定一个最低概率）。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>在算法初始阶段，它会随机生成一组可行解，也就是第一代染色体。</li><li>采用适应度函数分别计算每一条染色体的适应程度，并根据适应程度计算每一条染色体在下一次进化中被选中的概率(这个上面已经介绍，这里不再赘述)。<br>（上面都是准备过程，下面正式进入“进化”过程)</li><li>通过“交叉”，生成N-M条染色体；</li><li>对交叉后生成的N-M条染色体进行“变异”操作；</li><li>使用“复制”的方式生成M条染色体；</li><li>N条染色体生成完毕,紧接着分别计算N条染色体的适应度和下次被选中的概率。<br>(这就是一次进化的过程，紧接着进行新一轮的进化)</li></ol><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>进化次数允许范围：算法到达一定效果就停止，保证效率。</p><h2 id="进化策略"><a href="#进化策略" class="headerlink" title="进化策略"></a>进化策略</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>编码：对要求解的问题以数字串的方式进行编码（由目标参数和策略参数组成），计算合适度值</li><li>判断是否满足终止条件：如满足则输出结果；否则执行下述步骤</li><li>选择n个父代参与繁殖</li><li>按给定的方式执行交叉操作（可选）</li><li>基于高斯分布的扰动执行变异操作</li><li>产生m个子代，并计算合适度值（m&gt;n）</li><li>返回步骤2</li></ol><h2 id="进化规划"><a href="#进化规划" class="headerlink" title="进化规划"></a>进化规划</h2><ol><li>编码：对要求解的问题以数字串的方式进行编码（由目标参数和策略参数组成），计算合适度值</li><li>判断是否满足终止条件：如满足则输出结果；否则执行下述步骤</li><li>选择n个父代参与繁殖</li><li>基于高斯分布的扰动执行变异操作</li><li>产生n个子代，并计算合适度值</li><li>返回步骤2</li></ol><h2 id="进化策略、进化规划与遗传算法"><a href="#进化策略、进化规划与遗传算法" class="headerlink" title="进化策略、进化规划与遗传算法"></a>进化策略、进化规划与遗传算法</h2><ol><li><p>编码方面：不像传统遗传算法那样需要对要求解的问题进行0-1编码和解码，而是直接对求解的问题进行编码，即直接将优化问题的解表示为数字串的形式，不需要特定的编码和译码，可直接进行实数编码。</p></li><li><p>均采用同样的变异操作方式，即变异时，对父代中的个体加上一个服从均值为0，标准差为 σ 的高斯分布随机变量。标准差是变化的，编码时属于染色体串中的一部分。</p></li></ol><h2 id="进化策略与进化规划的差别"><a href="#进化策略与进化规划的差别" class="headerlink" title="进化策略与进化规划的差别"></a>进化策略与进化规划的差别</h2><ol><li>进化策略中的交叉算子是可选的；如需要进行交叉运算时，采用类似遗传算法的处理方法，如离散交叉或中值交叉方式。进化规划没有交叉算子。</li><li>父代选择方面：进化策略采用概率选择的方法形成父代（如基于随机分布的方式抽取父代个体），父代每一个个体都能以同样的概率被选中。 进化规划采用确定性方式，即当前种群中每个父代都要经过变异来产生子代。</li><li>变异表达式上的差异。</li><li>生存选择方面，即新的子代生成后，如何和父代共同形成新的父代的方式。</li></ol>]]></content>
    
    
    <summary type="html">进化算法主要涵盖的算法，包括其中各种算法的区别和联系</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="进化算法" scheme="http://woody5962.github.io/tags/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>启发式算法概述</title>
    <link href="http://woody5962.github.io/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://woody5962.github.io/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2021-07-01T12:56:19.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个基于直观或经验构造的算法，在可接受的花费（计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。</p><p>现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。</p><p>个人理解，所谓启发就是，没有精确的数学公式得到直接解的情况下，告诉机器该如何去发现指导信息，进而根据指导信息去寻找解。</p><h2 id="元启发式算法"><a href="#元启发式算法" class="headerlink" title="元启发式算法"></a>元启发式算法</h2><ul><li><a href="../%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95.md">模拟退火算法</a></li><li>遗传算法</li><li>列表搜索算法</li><li>进化规划</li><li>进化策略</li><li>蚁群算法</li><li>人工神经网络</li><li>禁忌搜索</li><li>粒子群优化</li></ul><h2 id="超启发式算法"><a href="#超启发式算法" class="headerlink" title="超启发式算法"></a>超启发式算法</h2><ul><li>基于随机选择的超启发式算法</li><li>基于贪心策略的超启发式算法</li><li>基于元启发式算法的超启发式算法</li><li>基于学习的超启发式算法</li></ul>]]></content>
    
    
    <summary type="html">启发式算法的定义和分类，以及一些个人的理解</summary>
    
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/categories/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="启发式算法" scheme="http://woody5962.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
