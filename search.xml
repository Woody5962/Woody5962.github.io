<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>局部搜索算法</title>
    <url>/%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>总是去找可能含有较优点的子集，最终找到的不一定是最优的点，但是具有较强的局部搜索能力。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li>随机选择一个初始的可能解x0 ∈D，xb=x0,P=N(xb)。<br>D是问题的定义域， xb用于记录到目标位置的最优解，P为xb的邻域。</li>
<li>如果不满足结束条件，则：</li>
</ol>
<p>Begin；</p>
<ul>
<li>选择P的一个子集P’，xn为P’的最优解。P’可根据问题特点，选择适当大小的子集。可按概率选择；</li>
<li>如果f(xn)&lt;f(xb)，则xb=xn，P=N(xb)，转2；</li>
<li>否则P=P-P’，转2；</li>
</ul>
<p>End（结束条件为循环次数或P为空等）；</p>
<ol start="3">
<li>输出计算结果；</li>
<li>结束</li>
</ol>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>局部搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式算法概述</title>
    <url>/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个基于直观或经验构造的算法，在可接受的花费（计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。</p>
<p>现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。</p>
<p>个人理解，所谓启发就是，没有精确的数学公式得到直接解的情况下，告诉机器该如何去发现指导信息，进而根据指导信息去寻找解。</p>
<h2 id="元启发式算法"><a href="#元启发式算法" class="headerlink" title="元启发式算法"></a>元启发式算法</h2><ul>
<li>模拟退火算法</li>
<li>遗传算法</li>
<li>列表搜索算法</li>
<li>进化规划</li>
<li>进化策略</li>
<li>蚁群算法</li>
<li>人工神经网络</li>
<li>禁忌搜索</li>
<li>粒子群优化</li>
</ul>
<h2 id="超启发式算法"><a href="#超启发式算法" class="headerlink" title="超启发式算法"></a>超启发式算法</h2><ul>
<li>基于随机选择的超启发式算法</li>
<li>基于贪心策略的超启发式算法</li>
<li>基于元启发式算法的超启发式算法</li>
<li>基于学习的超启发式算法</li>
</ul>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
      </tags>
  </entry>
  <entry>
    <title>禁忌搜索算法</title>
    <url>/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><img src="../images/jinji1.png" alt="jinji"><br>通过保持一个禁忌表，以禁忌长度进行禁忌，遵守禁忌准则和藐视准则进行全局搜索。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先，我们对置换问题定义一种邻域搜索结构，如互换操作（SWAP），即随机交换两个点的位置，则每个状态的邻域解有Cn2=n（n一1）/2个。称从一个状态转移到其邻域中的另一个状态为一次移动（move），显然每次移动将导致适配值（反比于目标函数值）的变化。其次，我们采用一个存储结构来区分移动的属性，即是否为禁忌“对象”在以下示例中：考虑7元素的置换问题，并用每一状态的相应21个邻域解中最优的5次移动（对应最佳的5个适配值）作为候选解；为一定程度上防止迂回搜索，每个被采纳的移动在禁忌表中将滞留3步（即禁忌长度），即将移动在以下连续3步搜索中将被视为禁忌对象；需要指出的是，由于当前的禁忌对象对应状态的适配值可能很好，因此在算法中设置判断，若禁忌对象对应的适配值优于“ best so far”状态，则无视其禁忌属性而仍采纳其为当前选择，也就是通常所说的藐视准则（或称特赦准则）。<br>注意，出于改善算法的优化时间性能的考虑，若领域结构决定了大量的领域解（尤其对大规模问题，如TSP的SWAP操作将产生Cn2个领域解），则可以仅尝试部分互换的结果，而候选解也仅取其中的少量最佳状态。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>简单TS算法的基本思想是：给定一个当前解（初始解）和一种邻域，然后在当前解的邻域中确定若干候选解；若最佳候选解对应的目标值优于“best so far”状态，则忽视其禁忌特性，用其替代当前解和“best so far”状态，并将相应的对象加入禁忌表，同时修改禁忌表中各对象的任期；若不存在上述候选解，则选择在候选解中选择非禁忌的最佳状态为新的当前解，而无视它与当前解的优劣，同时将相应的对象加入禁忌表，并修改禁忌表中各对象的任期；如此重复上述迭代搜索过程，直至满足停止准则。</p>
<p>　　条理化些，则简单禁忌搜索的算法步骤可描述如下：</p>
<p>　　（1）给定算法参数，随机产生初始解x，置禁忌表为空。</p>
<p>　　（2）判断算法终止条件是否满足？若是，则结束算法并输出优化结果；否则，继续以下步骤。</p>
<p>　　（3）利用当前解工的邻域函数产生其所有（或若干）邻域解，并从中确定若干候选解。</p>
<p>　　（4）对候选解判断藐视准则是否满足？若成立，则用满足藐视准则的最佳状态y替代x成为新的当前解，即x=y，并用与y对应的禁忌对象替换最早进入禁忌表的禁忌对象，同时用y替换“best so far”状态，然后转步骤6；否则，继续以下步骤。</p>
<p>　　（5）判断候选解对应的各对象的禁忌属性，选择候选解集中非禁忌对象对应的最佳状态为新的当前解，同时用与之对应的禁忌对象替换最早进入禁忌表的禁忌对象元素。</p>
<p>　　（6）转步骤（2）。</p>
<p>注意，根据（5）可知，最牛逼的解根本就不考虑它是不是在禁忌列表中，如果这些候选解都很弟弟，那就找非禁忌里面最优的了。这样，既可以保证不遗漏全局最优，又有利于跳出局部最优。</p>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>禁忌搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子群优化算法</title>
    <url>/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>假设有一群鸟，在随机搜索食物，在搜索区域内只有一块儿食物，一开始时所有的鸟儿都不知道食物所在的方位，但它们能够知道自己离食物有多远，以及它们能够记住在自己飞过的路程当中距离食物最近的位置，同时它们也能够知道鸟群中所有鸟儿经过的路程当中，离食物最近的位置。那每一只鸟儿将如何去寻找食物呢？简单来说，每一只鸟儿在当前位置的基础上，如何做出决策，下一步向哪里飞呢？实际，每只鸟儿将综合自身的经验，以及群体的经验来在做出下一步飞向哪里的决策，即每只鸟儿将根据自己所经过的路程中离食物最近的位置以及鸟群中所有鸟儿经过的路程当中离食物最近的位置来做出决策，决定下一步自己向哪里飞。</p>
<p>在粒子群算法中，粒子的位置对应于原问题的解。粒子的适应值就是将粒子的位置（对应于原问题的解）带入到目标函数中所得到的目标函数值。粒子的速度决定粒子下一步向哪里飞以及飞多远。</p>
<h2 id="核心公式"><a href="#核心公式" class="headerlink" title="核心公式"></a>核心公式</h2><p><img src="../images/pso1.png" alt="gs"></p>
<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><p><img src="../images/pso2.png" alt="gs"></p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>粒子群算法整合了个体与整体的智慧，在“信息素”更新的时候，综合考虑了个体和整体在过去的发现。调整参数可以避免陷入局部最优，同时也可以决定对个体或者整体的依赖程度。个人认为，整体越大，对整体的依赖程度就要越大，这个依赖程度应该和粒子数量成正相关关系。</p>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>粒子群算法</tag>
      </tags>
  </entry>
  <entry>
    <title>进化算法</title>
    <url>/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>进化算法主要包括：</p>
<ul>
<li>遗传算法</li>
<li>进化程序设计</li>
<li>进化规划</li>
<li>进化策略</li>
</ul>
<p>之后的文章记录遗传算法、进化规划、进化策略三种算法的理解。</p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>适者生存，优胜劣汰！</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="概念0：编码与解码"><a href="#概念0：编码与解码" class="headerlink" title="概念0：编码与解码"></a>概念0：编码与解码</h4><p>要将问题进行数学建模，将问题的解利用二进制数字串进行表示。<br>而进行适应度分析时，要将其解码成特征进行评价。</p>
<h4 id="概念1：基因和染色体"><a href="#概念1：基因和染色体" class="headerlink" title="概念1：基因和染色体"></a>概念1：基因和染色体</h4><p>在遗传算法中，我们首先需要将要解决的问题映射成一个数学问题，也就是所谓的“数学建模”，那么这个问题的一个可行解即被称为一条“染色体”。一个可行解一般由多个元素构成，那么这每一个元素就被称为染色体上的一个“基因”。</p>
<h4 id="概念2：适应度函数"><a href="#概念2：适应度函数" class="headerlink" title="概念2：适应度函数"></a>概念2：适应度函数</h4><p>给染色体打分（评价解的优良程度）</p>
<h4 id="概念3：交叉"><a href="#概念3：交叉" class="headerlink" title="概念3：交叉"></a>概念3：交叉</h4><p>遗传算法每一次迭代都会生成N条染色体，在遗传算法中，这每一次迭代就被称为一次“进化”。交叉算子种类很多，具体使用时找收藏夹，要注意有的交叉算子处理之后要进行冲突检查。</p>
<h4 id="概念4：变异"><a href="#概念4：变异" class="headerlink" title="概念4：变异"></a>概念4：变异</h4><p>当我们通过交叉生成了一条新的染色体后，需要在新染色体上随机选择若干个基因，然后随机修改基因的值，从而给现有的染色体引入了新的基因，突破了当前搜索的限制，更有利于算法寻找到全局最优解。交叉只能找到局部最优解，永远没有办法达到全局最优解。</p>
<h4 id="概念5：复制"><a href="#概念5：复制" class="headerlink" title="概念5：复制"></a>概念5：复制</h4><p>每次进化中，为了保留上一代优良的染色体，需要将上一代中适应度最高的几条染色体直接原封不动地复制给下一代。假设每次进化都需生成N条染色体，那么每次进化中，通过交叉方式需要生成N-M条染色体，剩余的M条染色体通过复制上一代适应度最高的M条染色体而来。</p>
<h4 id="概念6：选择"><a href="#概念6：选择" class="headerlink" title="概念6：选择"></a>概念6：选择</h4><p>如何从群体中找到染色体进行交叉，这涉及到一定的选择策略，常用的有轮盘赌选择策略、锦标赛选择策略、线性排序选择（Linear Ranking Selection）和指数排序选择（Exponential Ranking Selection）。后面两种选择策略避免了轮盘赌的一个缺点，那就是可以让适应度为0的个体也有机会产生后代（会确定一个最低概率）。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>在算法初始阶段，它会随机生成一组可行解，也就是第一代染色体。</li>
<li>采用适应度函数分别计算每一条染色体的适应程度，并根据适应程度计算每一条染色体在下一次进化中被选中的概率(这个上面已经介绍，这里不再赘述)。<br>（上面都是准备过程，下面正式进入“进化”过程)</li>
<li>通过“交叉”，生成N-M条染色体；</li>
<li>对交叉后生成的N-M条染色体进行“变异”操作；</li>
<li>使用“复制”的方式生成M条染色体；</li>
<li>N条染色体生成完毕,紧接着分别计算N条染色体的适应度和下次被选中的概率。<br>(这就是一次进化的过程，紧接着进行新一轮的进化)</li>
</ol>
<h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>进化次数允许范围：算法到达一定效果就停止，保证效率。</p>
<h2 id="进化策略"><a href="#进化策略" class="headerlink" title="进化策略"></a>进化策略</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>编码：对要求解的问题以数字串的方式进行编码（由目标参数和策略参数组成），计算合适度值</li>
<li>判断是否满足终止条件：如满足则输出结果；否则执行下述步骤</li>
<li>选择n个父代参与繁殖</li>
<li>按给定的方式执行交叉操作（可选）</li>
<li>基于高斯分布的扰动执行变异操作</li>
<li>产生m个子代，并计算合适度值（m&gt;n）</li>
<li>返回步骤2</li>
</ol>
<h2 id="进化规划"><a href="#进化规划" class="headerlink" title="进化规划"></a>进化规划</h2><ol>
<li>编码：对要求解的问题以数字串的方式进行编码（由目标参数和策略参数组成），计算合适度值</li>
<li>判断是否满足终止条件：如满足则输出结果；否则执行下述步骤</li>
<li>选择n个父代参与繁殖</li>
<li>基于高斯分布的扰动执行变异操作</li>
<li>产生n个子代，并计算合适度值</li>
<li>返回步骤2</li>
</ol>
<h2 id="进化策略、进化规划与遗传算法"><a href="#进化策略、进化规划与遗传算法" class="headerlink" title="进化策略、进化规划与遗传算法"></a>进化策略、进化规划与遗传算法</h2><ol>
<li><p>编码方面：不像传统遗传算法那样需要对要求解的问题进行0-1编码和解码，而是直接对求解的问题进行编码，即直接将优化问题的解表示为数字串的形式，不需要特定的编码和译码，可直接进行实数编码。</p>
</li>
<li><p>均采用同样的变异操作方式，即变异时，对父代中的个体加上一个服从均值为0，标准差为 σ 的高斯分布随机变量。标准差是变化的，编码时属于染色体串中的一部分。</p>
</li>
</ol>
<h2 id="进化策略与进化规划的差别"><a href="#进化策略与进化规划的差别" class="headerlink" title="进化策略与进化规划的差别"></a>进化策略与进化规划的差别</h2><ol>
<li>进化策略中的交叉算子是可选的；如需要进行交叉运算时，采用类似遗传算法的处理方法，如离散交叉或中值交叉方式。进化规划没有交叉算子。</li>
<li>父代选择方面：进化策略采用概率选择的方法形成父代（如基于随机分布的方式抽取父代个体），父代每一个个体都能以同样的概率被选中。 进化规划采用确定性方式，即当前种群中每个父代都要经过变异来产生子代。</li>
<li>变异表达式上的差异。</li>
<li>生存选择方面，即新的子代生成后，如何和父代共同形成新的父代的方式。</li>
</ol>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>进化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>蚁群算法</title>
    <url>/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>将蚁群算法应用于解决优化问题的基本思路为：用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上累积的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</p>
<h2 id="算法流程（蚁群解决TSP）"><a href="#算法流程（蚁群解决TSP）" class="headerlink" title="算法流程（蚁群解决TSP）"></a>算法流程（蚁群解决TSP）</h2><p><img src="../images/yiqun1.jpg" alt="yiqun"></p>
<h3 id="选择下一座城市的规则"><a href="#选择下一座城市的规则" class="headerlink" title="选择下一座城市的规则"></a>选择下一座城市的规则</h3><p><img src="../images/yiqun2.png" alt="yiqun"></p>
<ul>
<li><p>由选择公式可见，分母是所有可选路径的信息素的和，而某路径信息素越浓，选中它的概率越大。</p>
</li>
<li><p>同时，给出了beta参数作为启发信息的权重，在这里，启发信息正如其名，是一种启发，根据其初值可知，哪条路径最短，其被选中的概率就越高。在早期，就是这样的启发信息来促使算法少走弯路。</p>
</li>
</ul>
<h3 id="信息素更新规则"><a href="#信息素更新规则" class="headerlink" title="信息素更新规则"></a>信息素更新规则</h3><p><img src="../images/yiqun3.png" alt="yiqun"></p>
<p><img src="../images/yiqun4.png" alt="yiqun"></p>
<ul>
<li><p>当Lk 计算完毕之后，得到目前最优解，根据最优解的路径更新信息素。</p>
</li>
<li><p>可见，信息素在更新之前，先削弱了旧信息素的影响，然后将最优路径的信息素添加进去，由于最优，所以L小，信息素大。</p>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>实际实验中发现，当蚂蚁在一条路径上觅食很久时，放置一个近的食物基本没有效果，这可以理解为当一只蚂蚁找到一条路径时，在经过很长时间后大多数蚂蚁都选择了这条路径，这时，突然有一只蚂蚁找到了较近的食物，但因为时间过得太久，两条路径上浓度相差太大（浓度越大，被选择的概率就越大），整个系统基本已经停滞了，陷入了局部最优。</p>
]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>蚁群算法</tag>
      </tags>
  </entry>
</search>
